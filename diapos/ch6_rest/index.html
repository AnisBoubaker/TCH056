<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>CH05- REST | TCH056</title>

    <base target="_blank" />

    <link rel="stylesheet" href="../revealjs/reset.css" />
    <link rel="stylesheet" href="../revealjs/reveal.css" />
    <link rel="stylesheet" href="../revealjs/theme/ets.css" id="theme" />
    <link rel="stylesheet" href="../revealjs/theme/normalize.css" />
    <link rel="stylesheet" href="./css/examples_general.css" />
    <link rel="stylesheet" href="./css/examples.css" />
    <link rel="stylesheet" href="../timeline/css/timeline.min.css" />
    <link rel="stylesheet" href="./ch4.css" />
    <link rel="stylesheet" href="../jqtree.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="../revealjs/plugin/highlight/docco.css"
      id="highlight-theme"
    />

    <script src="../jquery-3.6.4.min.js"></script>
  </head>
  <body>
    <!--
					
		-->
    <div class="reveal">
      <div id="slide_nb" style="display: none">Attention...</div>
      <div class="titre_cours">TCH056 - Programmation Web</div>
      <div class="slides">
        <section>
          <img src="../images/logo_ets.png" />
          <h4 class="">TCH056 - Programmation Web</h4>
          <h2 class="r-fit-text">&lt;Chapitre 06&gt; Les APIs REST</h2>
          <br /><br />
          <p>
            <strong>Anis Boubaker, Ph.D.</strong><br />
            <em>Prof. Enseignant en informatique</em>
          </p>
        </section>

        <!-- Plan du chapitre -->
        <section data-transition="convex">
          <h2>Plan du chapitre</h2>
          <div class="two_columns_layout">
            <div class="col menu-principal">
              <ul class="">
                <li class="plan-current">Introduction à REST</li>
                <li>Conception d'une API REST</li>
                <li>Communication avec une API REST</li>
                <li>REST avec PHP</li>
                <li>Routage</li>
                <li>Authentification et sécurité</li>
              </ul>
            </div>
            <div class="col sous-menu">
              <ul style="margin: 0">
                <li>Définition</li>
                <li>Autres types d'API</li>
                <li>Principes de base</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Diapositive 2: Définition et importance des API -->
        <section>
          <h2>Qu'est-ce qu'une API ?</h2>
          <p>API signifie Interface de Programmation d'Application.</p>
          <p>Elles permettent la communication entre différents logiciels.</p>
          <p>
            <b>Exemple :</b> L'API de Twitter permet d'intégrer ses
            fonctionnalités dans d'autres applications.
          </p>
        </section>

        <section>
          <h2>Une API offre des services</h2>
          <image src="./images/rest-offre-services.webp" style="width: 600px" />
        </section>

        <!-- Diapositive 3: Différence entre API REST et autres types d'API -->
        <section>
          <section>
            <h2>API REST</h2>
            <p>REST signifie Representational State Transfer.</p>
            <p>
              Utilise des requêtes HTTP pour GET, POST, PUT, DELETE des données.
            </p>
            <p><b>Exemple :</b> API RESTful de GitHub.</p>
          </section>
          <section>
            <h2>API SOAP</h2>
            <p>SOAP signifie Simple Object Access Protocol.</p>
            <p>Basé sur XML, plus strict et sécurisé.</p>
            <p><b>Exemple :</b> Service web de Microsoft Exchange.</p>
          </section>
          <section>
            <h2>API GraphQL</h2>
            <p>GraphQL est une alternative à REST.</p>
            <p>
              Offre aux clients de demander exactement les données dont ils ont
              besoin.
            </p>
            <p>
              Évite les problèmes de surcharges de données (overfetching) ou des
              demandes de données insuffisantes (underfetching)
            </p>
            <p><b>Exemple :</b> API de GitHub v4.</p>
          </section>
        </section>

        <!-- Diapositive 1: Architecture sans état (Stateless) -->
        <section>
          <h2>Architecture sans état (Stateless)</h2>
          <p>Chaque requête de l'API REST est indépendante des autres.</p>
          <p>
            Le serveur ne stocke pas d'informations sur l'état du client entre
            les requêtes.
          </p>
          <p>
            <b>Exemple :</b> Une requête GET pour récupérer des données ne
            dépend pas des requêtes précédentes.
          </p>
        </section>

        <!-- Diapositive 2: Utilisation des méthodes HTTP -->
        <section>
          <h2>Utilisation des méthodes HTTP</h2>
          <ul>
            <li><b>GET</b> - Récupérer des données.</li>
            <li><b>POST</b> - Créer une nouvelle ressource.</li>
            <li><b>PUT</b> - Mettre à jour une ressource existante.</li>
            <li><b>DELETE</b> - Supprimer une ressource.</li>
          </ul>
          <p><b>Exemple :</b> POST /users pour créer un nouvel utilisateur.</p>
        </section>

        <section>
          <h2>Requête REST: Méthode + Ressource</h2>
          <img src="./images/rest-api.png" />
          <p class="note">Source: mannhowie.com</p>
        </section>

        <section>
          <h2>Indépendante du langages ou de la plateforme</h2>
          <p>Une API REST permet d’interagir avec la couche métier:</p>
          <ul>
            <li>Peu importe l'interface usager (Web, mobile, desktop)</li>
            <li>
              Peu importe la technologie sous-jacente (langage de programmation,
              cadriciels, etc.)
            </li>
          </ul>
        </section>

        <section>
          <h2>Une API Universelle</h2>
          <img src="./images/api_universelle.webp" style="width: 600px" />
        </section>

        <section>
          <h2>Standards Ouverts</h2>
          <ul>
            <li>La communication se fait à travers le protocole HTTP</li>
            <li>
              Les données sont échangées en utilisant des formats largement
              supportés comme JSON (principalement) ou XML.
            </li>
          </ul>
        </section>

        <!-- Plan du chapitre -->
        <section data-transition="convex">
          <h2>Plan du chapitre</h2>
          <div class="two_columns_layout">
            <div class="col menu-principal">
              <ul class="">
                <li class="plan-visted">Introduction à REST</li>
                <li class="plan-current">Conception d'une API REST</li>
                <li>Communication avec une API REST en JS</li>
                <li>REST avec PHP</li>
                <li>Routage</li>
                <li>Authentification et sécurité</li>
              </ul>
            </div>
            <div class="col sous-menu">
              <ul style="margin: 0">
                <li>Ressources et URI</li>
                <li>Formats de réponses</li>
                <li>Planification</li>
                <li>Bonnes pratiques</li>
              </ul>
            </div>
          </div>
        </section>

        <!-- Diapositive 3: Structure des URL et des ressources -->
        <section>
          <h2>Structure des URL et des ressources</h2>
          <p>
            Les URL identifient les ressources, et la structure des URL doit
            être logique et prévisible.
          </p>
          <p>
            <b>Exemple :</b> GET /users/123 pour récupérer l'utilisateur avec
            l'ID 123.
          </p>
          <p>
            Les ressources sont souvent organisées en collections et éléments.
          </p>
        </section>

        <!-- Diapositive 4: Formats de réponse -->
        <section>
          <h2>Formats de réponse</h2>
          <p>
            Les API REST peuvent retourner des données dans différents formats.
          </p>
          <ul>
            <li>
              <b>JSON</b> (JavaScript Object Notation) - Format léger et facile
              à lire.
            </li>
            <li>
              <b>XML</b> (eXtensible Markup Language) - Plus verbeux, utilisé
              dans les systèmes plus anciens.
            </li>
          </ul>
          <p>
            Le format JSON est davantage utilisé que le format XML (interprété
            nativement par JavaScript)
          </p>
        </section>

        <!-- Diapositive: Exemple de Réponse JSON avec une Liste d'Utilisateurs -->
        <section>
          <h2>Exemple de Réponse JSON</h2>
          <p>
            Voici comment une API REST pourrait retourner une liste
            d'utilisateurs en format JSON :
          </p>
          <pre><code class="json" data-trim contenteditable>
          {
          "users": [
            {
              "id": 1,
              "name": "Alice Dupont",
              "email": "alice.dupont@example.com",
              "role": "admin"
            },
            {
              "id": 2,
              "name": "Bob Martin",
              "email": "bob.martin@example.com",
              "role": "user"
            },
            {
              "id": 3,
              "name": "Charlie Nom",
              "email": "charlie.nom@example.com",
              "role": "user"
            }
          ]
          }
          </code></pre>
        </section>

        <!-- Diapositive: Exemple de Réponse XML avec une Liste d'Utilisateurs -->
        <section>
          <h2>Exemple de Réponse XML</h2>
          <p>
            Voici comment une API REST pourrait retourner une liste
            d'utilisateurs en format XML :
          </p>
          <pre><code class="xml" data-trim contenteditable>
          &lt;users&gt;
            &lt;user&gt;
                &lt;id&gt;1&lt;/id&gt;
                &lt;name&gt;Alice Dupont&lt;/name&gt;
                &lt;email&gt;alice.dupont@example.com&lt;/email&gt;
                &lt;role&gt;admin&lt;/role&gt;
            &lt;/user&gt;
            &lt;user&gt;
                &lt;id&gt;2&lt;/id&gt;
                &lt;name&gt;Bob Martin&lt;/name&gt;
                &lt;email&gt;bob.martin@example.com&lt;/email&gt;
                &lt;role&gt;user&lt;/role&gt;
            &lt;/user&gt;
            &lt;user&gt;
                &lt;id&gt;3&lt;/id&gt;
                &lt;name&gt;Charlie Nom&lt;/name&gt;
                &lt;email&gt;charlie.nom@example.com&lt;/email&gt;
                &lt;role&gt;user&lt;/role&gt;
            &lt;/user&gt;
          &lt;/users&gt;
          </code></pre>
        </section>

        <!-- Diapositive 1: Planification des Ressources -->
        <section>
          <h2>Planification des Ressources</h2>
          <p>
            Identifier les principales entités de l'application (ex:
            utilisateurs, articles, commentaires).
          </p>
          <p>Chaque entité devient une ressource dans l'API.</p>
          <p>Exemples :</p>
          <ul>
            <li>Utilisateurs (users)</li>
            <li>Articles (articles)</li>
            <li>Commentaires (comments)</li>
          </ul>
        </section>

        <!-- Diapositive 2: Définition des Routes et Méthodes -->
        <section>
          <h2>Définition des Routes et Méthodes</h2>
          <p>Créer des routes pour interagir avec les ressources.</p>
          <p>
            Utiliser les méthodes HTTP appropriées (GET, POST, PUT, DELETE).
          </p>
          <p>Exemples de routes :</p>
          <pre><code>
          GET /users - Récupérer la liste des utilisateurs
          POST /users - Créer un nouvel utilisateur
          GET /users/{id} - Récupérer un utilisateur spécifique
          PUT /users/{id} - Mettre à jour un utilisateur
          DELETE /users/{id} - Supprimer un utilisateur
          </code></pre>
        </section>

        <!-- Diapositive 3: Bonnes Pratiques - Naming Conventions -->
        <section>
          <h2>Bonnes Pratiques: Conventions de nommage</h2>
          <p>Utiliser des noms clairs et cohérents pour les routes.</p>
          <p>Préférer le pluriel pour les noms de ressources.</p>
          <p>
            Exemple : /users pour les utilisateurs, /articles pour les articles.
          </p>
        </section>

        <!-- Diapositive 4: Bonnes Pratiques - Versioning -->
        <section>
          <h2>Bonnes Pratiques: Versioning</h2>
          <ul>
            <li>
              Inclure la version de l'API dans l'URL pour faciliter les mises à
              jour futures.
            </li>
            <li>Utiliser la technique du versionnage sémantique</li>
          </ul>
          <p>Exemple : /v1.1.0/users, /v2.2.1/users</p>
        </section>

        <!-- Diapositive 5: Bonnes Pratiques - Sécurité -->
        <section>
          <h2>Bonnes Pratiques: Sécurité</h2>
          <p>Assurer la sécurité des données et des communications.</p>
          <ul>
            <li>Utiliser HTTPS pour chiffrer les données en transit.</li>
            <li>Authentification (ex: OAuth, JWT).</li>
            <li>
              Validation et nettoyage des entrées pour prévenir les injections
              SQL.
            </li>
          </ul>
        </section>

        <!-- Diapositive 6: Bonnes Pratiques - Gestion des Erreurs -->
        <section>
          <h2>Bonnes Pratiques: Gestion des Erreurs</h2>
          <p>Fournir des messages d'erreur clairs et informatifs.</p>
          <ul>
            <li>Utiliser des codes d'état HTTP appropriés.</li>
            <li>
              Messages d'erreur en format JSON avec code d'erreur, message et
              éventuellement des détails.
            </li>
          </ul>
        </section>

        <!-- Diapositive 7: Bonnes Pratiques - Documentation -->
        <section>
          <h2>Bonnes Pratiques: Documentation</h2>
          <p>Une documentation complète et à jour est cruciale.</p>
          <ul>
            <li>
              Utiliser des outils comme Swagger ou Redoc pour créer une
              documentation interactive.
            </li>
            <li>Inclure des exemples de requêtes et de réponses.</li>
          </ul>
        </section>

        <!-- Diapositive 8: Bonnes Pratiques - Performance -->
        <section>
          <h2>Bonnes Pratiques: Performance</h2>
          <p>
            Optimiser la performance de l'API pour une meilleure expérience
            utilisateur.
          </p>
          <ul>
            <li>Mise en cache des réponses lorsque c'est possible.</li>
            <li>Limitation (rate limiting) pour prévenir l'abus de l'API.</li>
            <li>
              Utilisation de techniques de pagination pour les grandes
              collections de données.
            </li>
          </ul>
        </section>

        <!-- Diapositive 9: Bonnes Pratiques - Scalabilité -->
        <section>
          <h2>Bonnes Pratiques: Scalabilité</h2>
          <p>
            Concevoir l'API pour qu'elle puisse gérer l'augmentation du trafic.
          </p>
          <ul>
            <li>
              Architecture microservices pour faciliter la montée en charge.
            </li>
            <li>
              Équilibrage de charge et utilisation de serveurs de réplication.
            </li>
          </ul>
        </section>

        <!-- Plan du chapitre -->
        <section data-transition="convex">
          <h2>Plan du chapitre</h2>
          <div class="two_columns_layout">
            <div class="col menu-principal">
              <ul class="">
                <li class="plan-visited">Introduction à REST</li>
                <li class="plan-visited">Conception d'une API REST</li>
                <li class="plan-current">Communication avec une API REST</li>
                <li>REST avec PHP</li>
                <li>Routage</li>
                <li>Authentification et sécurité</li>
              </ul>
            </div>
            <div class="col sous-menu">
              <ul style="margin: 0">
                <li>Accès à une API REST</li>
                <li>Communication asynchrone avec l'API</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <h2>Accès à une API REST</h2>
          <p>
            Tous les langages de programmation qui permettent la communication à
            travers le port HTTP permettent de ce connecter à une API REST.
          </p>
          <p>
            Lors de la conception d'une API REST, plusieurs outils permettent
            d'y accéder aux fins de tests:
          </p>
          <ul>
            <li>Postman</li>
            <li>Insomnia</li>
            <li>Thunder Client (VS Code)</li>
            <li>...</li>
          </ul>
        </section>

        <section>
          <h2>Exemples d'APIs librement accessibles</h2>
          <ul>
            <li>
              <a href="https://openweathermap.org/api">OpenWeatherMap</a>:
              Données météorologiques globales (prévisions + historiques)
            </li>
            <li>
              <a href="https://developers.themoviedb.org/3"
                >The Movie Database</a
              >: Base de données communautaire de films et de séries TV
            </li>
            <li>
              <a href="https://jokeapi.dev">JokeAPI</a>: Blagues dans diverses
              catégories
            </li>
            <li>
              <a href="https://api.nasa.gov/">NASA API</a>: Accès à une
              multitude de données spatiales, y compris des images de la NASA,
              des informations sur les missions, et plus encore.
            </li>
            <li>
              <a href="https://randomuser.me">Random User Generator</a>: Utile
              pour générer des profils d'utilisateurs fictifs pour des tests ou
              des maquettes
            </li>
          </ul>
        </section>

        <section>
          <h2>Communication REST avec Javascript</h2>
          <p>
            Pour ne pas bloquer la pile d'exécution, les communications avec une
            API se font de façon asynchrone.
          </p>
          <p class="fragment">
            Plusieurs méthodes permettent la communication HTTP asynchrone
            (notamment avec une API REST):
          </p>
          <ul>
            <li class="fragment">
              L'objet XMLHttpRequest: Objet disponible dans tous les navigateurs
              depuis IE5 (1999)
            </li>
            <li class="fragment">
              Plusieurs librairies: Comme jQuery (généraliste) et Axios
              (spécifique aux requêtes)
            </li>
            <li class="fragment">
              La fonction <code>fetch</code>: Méthode moderne implantée dans
              tous les navigateurs contemporains
            </li>
          </ul>
        </section>

        <section>
          <h2>La fonction <code>fetch</code></h2>
          <ul>
            <li>
              <code>fetch</code> utilise les 'Promesses' qui est un mécanisme
              d'exécution des fonctions de façon asynchrone
            </li>
            <li>
              Une requête HTTP se fait en deux étapes avec fetch:
              <pre><code class="javascript" data-trim>
                fetch("URI", { ...options })
                  .then((response)=>{
                    //fonction de rappel qui traite la réponses HTTP 
                    //et retourne les données (fonction asynchrone)
                  })
                  .then((data)=>{
                    //fonction de rappel pour traiter les données 
                  })
                  .catch((error)=>{
                    //fonction de rappel pour traiter les erreurs 
                    //éventuelles. 
                  })
              </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>Exemple avec <code>fetch</code> (GET)</h2>
          <pre><code class="javascript" data-trim>
            fetch("https://jsonplaceholder.typicode.com/posts/3", 
                  { method: "GET" })
            .then((response) => {
              if (!response.ok) {
                throw new Error("Erreur HTTP: " + response.statusText);
              }
              return response.json();
            })
            .then((data) => {
              if (data.error)
                throw new Error("Erreur reçue du serveur: " + data.error);

              console.log(data);
            })
            .catch((error) =>
              console.error(
                "Il y'a eu une erreur lors de l'obtention des données:" +
                  error.message
              )
            );
          </code></pre>
        </section>

        <section>
          <h2>Exemple avec <code>fetch</code> (POST)</h2>
          <pre><code class="javascript" data-trim>
            fetch('https://jsonplaceholder.typicode.com/posts', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                title: 'Mon post',
                body: 'Je teste si mon post sera stocké',
                userId: 1,
              }),
            })
            .then(response => {
              if (!response.ok) {
                throw new Error('Erreur reçue du serveur'+response.statusText);
              }
              return response.json();
            })
            .then(data => console.log(data))
            .catch(error => console.error('Il y a eu une erreur:', error.message));
          </code></pre>
        </section>

        <section>
          <h2>Exemple avec <code>fetch</code> (PUT)</h2>
          <pre><code class="javascript" data-trim>
            // L'URL de l'API pour le post avec l'ID 1
            const url = 'https://jsonplaceholder.typicode.com/posts/1';

            // Les données que nous souhaitons mettre à jour
            const data = {
              id: 1, // Normalement, vous n'avez pas besoin de fournir 
                     // l'ID dans le corps pour une requête PUT, 
                     //mais JSONPlaceholder l'exige pour la simulation.
              title: 'Nouveau titre',
              body: 'Nouveau contenu',
              userId: 1,
            };

            // Options de la requête fetch pour effectuer une opération PUT
            const fetchOptions = {
              method: 'PUT', // Méthode HTTP utilisée
              headers: {
                // Indique que le corps de la requête est au format JSON
                'Content-Type': 'application/json', 
              },
              // Convertit les données de l'objet JavaScript en chaîne JSON
              body: JSON.stringify(data), 
            };

            // Effectuer la requête PUT
            fetch(url, fetchOptions)
              .then(response => {
                if (!response.ok) {
                  // Si la réponse n'est pas dans la plage de succès HTTP (200-299),
                  // lance une erreur avec le statut pour indiquer l'échec de la requête
                  throw new Error('Le serveur a renvoyé une erreur');
                }
                return response.json(); // Parse la réponse en JSON
              })
              .then(updatedPost => {
                console.log('Post mis à jour:', updatedPost); // Affiche les données du post mis à jour
              })
              .catch(error => {
                console.error("Il y a eu une error lors de l'opération fetch:", error);
              });

          </code></pre>
        </section>

        <!-- Plan du chapitre -->
        <section data-transition="convex">
          <h2>Plan du chapitre</h2>
          <div class="two_columns_layout">
            <div class="col menu-principal">
              <ul class="">
                <li class="plan-visited">Introduction à REST</li>
                <li class="plan-visited">Conception d'une API REST</li>
                <li class="plan-visited">Communication avec une API REST</li>
                <li class="plan-current">Conception d'une API REST avec PHP</li>
              </ul>
            </div>
            <div class="col sous-menu">
              <ul style="margin: 0">
                <li>Routage et définition des routes</li>
                <li>Authentification</li>
                <li>Traitement des requêtes</li>
                <li>Gestion des erreurs</li>
                <li>Tests de l'API</li>
              </ul>
            </div>
          </div>
        </section>

        <section>
          <h2>Traitement normal des requêtes HTTP</h2>
          <img src="./images/diag_no_routing.png" />
        </section>

        <section>
          <h2>Routage</h2>
          <ul>
            <li>
              <strong>Définition:</strong> Le routage est le processus qui
              dirige les requêtes HTTP vers le bon contrôleur et la méthode de
              contrôleur, basé sur l'URL de la requête et la méthode HTTP (GET,
              POST, PUT, DELETE, etc.).
            </li>
            <li class="fragment">
              <strong>Objectif:</strong> Permettre une interaction structurée et
              prévisible avec une application web ou un service en utilisant des
              URLs et des méthodes HTTP spécifiques.
            </li>
          </ul>
        </section>

        <section>
          <h2>Fonctionnement du routage</h2>
          <ol>
            <li>Le client envoie une requête (URL+méthode)</li>
            <li class="fragment">La requête est traitée par le routeur</li>
            <li class="fragment">
              Le routeur valide la requête et la renvoie au contrôleur approprié
            </li>
            <li class="fragment">
              Le contrôleur traite la requête et génère la réponse
            </li>
            <li class="fragment">La réponse est renvoyée au client</li>
          </ol>
        </section>

        <section>
          <h2>Fonctionnement du routage (illustration)</h2>
          <img src="./images/diag_routing.png" />
        </section>

        <section>
          <h2>Avantages du routage</h2>
          <ul>
            <li>Clarté: organisation de logique des routes (ex.: web, api)</li>
            <li>
              Modularité: séparer les préoccupation entre la requête et le
              contrôleur
            </li>
            <li>Ré-utilisabilité: Facilite la réutilisation de contrôleurs</li>
            <li>
              Évolutivité: l'ajout ou le retrait de routes est facile et
              prévisible
            </li>
            <li>
              Lisibilité: Possible de définir des routes plus faciles (ne
              dépendent pas des noms de fichiers)
            </li>
          </ul>
        </section>

        <section>
          <h2>Routage - Implémentation</h2>
          <ul>
            <li>
              Utilisation du module mod_rewrite pour rediriger toutes les
              requêtes qui ne sont pas des images vers le routeur
            </li>
            <li>
              Sur Apache: ajout d'un fichier <code>.htaccess</code> à la racine
            </li>
            <li>
              Ce fichier demande que toute requête autre que les images, pdf,
              zip, css, etc. soient redirigées vers le fichiers routes.php
            </li>
          </ul>

          <pre><code class="text" data-trim>
            RewriteEngine On
            RewriteCond %{REQUEST_URI}  !(\.png|\.jpg|\.webp|\.gif|\.jpeg|\.zip|\.css|\.svg|\.js|\.pdf)$
            RewriteRule (.*) routes.php [QSA,L]% 
          </code></pre>
        </section>

        <section>
          <h2>Routage - Implémentation</h2>
          <p>
            Le fichier routes.php définit quelles sont les routes valides et
            renvoie chacune vers le contrôleur approprié:
          </p>
          <pre><code class="php" data-trim="">
            &lt;?php
            // Obtention du chemin de l'URL après le nom de domaine
            $request = $_SERVER['REQUEST_URI'];
            // Routeur simple
            switch ($request) {
                case '/' :
                    require __DIR__ . '/views/home.php';
                    break;
                case '/about' :
                    require __DIR__ . '/views/about.php';
                    break;
                case '/contact' :
                    require __DIR__ . '/views/contact.php';
                    break;
                default:
                    // Gestion des pages non trouvées
                    http_response_code(404);
                    require __DIR__ . '/views/404.php';
                    break;
            }
          </code></pre>
        </section>

        <section>
          <h2>Types de routes</h2>
          <p>
            Les routes peuvent être des routes
            <span class="highlight2">statiques</span> ou
            <span class="highlight2">dynamiques</span>
          </p>
        </section>

        <section>
          <h2>Routes statiques</h2>
          <ul>
            <li>
              <strong>Définition:</strong> Une route statique est un chemin
              d'URL qui pointe vers une ressource spécifique ou un contrôleur
              sans variation. L'URL est fixe et ne change pas.
            </li>
            <li class="fragment">
              <strong>Exemple:</strong> /about ou /contact qui mènent
              respectivement à la page À propos et à la page Contact.
            </li>
            <li class="fragment">
              <strong>Utilisation:</strong> Idéal pour les pages ou les API
              endpoints qui ne nécessitent pas de données variables dans l'URL.
            </li>
          </ul>
        </section>

        <section>
          <h2>Routes dynamiques</h2>
          <ul>
            <li>
              <strong>Définition:</strong> utilise des parties variables dans
              l'URL pour passer des données ou des paramètres au contrôleur. Ces
              parties variables sont souvent appelées paramètres de route.
            </li>
            <li class="fragment">
              <strong>Exemple:</strong> <code>/users/:userId</code> où
              <code>:userId</code>
              est un paramètre dynamique qui peut représenter l'identifiant d'un
              utilisateur spécifique.
            </li>
            <li class="fragment">
              <strong>Utilisation:</strong> Permet de construire des
              applications et des API flexibles qui peuvent gérer une grande
              variété de requêtes avec un nombre réduit de routes.
            </li>
          </ul>
        </section>

        <section>
          <h2>Routeur: Gestion des routes statiques/dynamiques</h2>
          <pre><code class="php" data-trim="">
            $request = $_SERVER['REQUEST_URI'];

            // Utilisez preg_match pour vérifier les routes dynamiques
            if ( $_SERVER["REQUEST_METHOD"]=="GET" &&
              preg_match('/^\/api\/clients\/(\d+)$/', $request, $matches)) {
                // $matches[1] contient l'ID capturé dans l'URL
                $clientId = $matches[1];
                require __DIR__ . '/api/getClient.php';
            } else if(){
              if ( $_SERVER["REQUEST_METHOD"]=="PUT" &&
              preg_match('/^\/api\/clients\/(\d+)$/', $request, $matches)) {
                // $matches[1] contient l'ID capturé dans l'URL
                $clientId = $matches[1];
                require __DIR__ . '/api/putClient.php';
            } else {
                switch ($request) {
                    case '/' :
                        require __DIR__ . '/views/home.php';
                        break;
                    case '/about' :
                        require __DIR__ . '/views/about.php';
                        break;
                    case '/contact' :
                        require __DIR__ . '/views/contact.php';
                        break;
                    default:
                        http_response_code(404);
                        require __DIR__ . '/views/404.php';
                        break;
                }
            }
          </code></pre>
        </section>

        <section>
          <h2>Librairies pour le routage</h2>
          <ul>
            <li>
              La logique de routage avec toutes les variations d'URL
              statistiques et dynamiques peut rapidement devenir incontrôlable
            </li>
            <li>
              Lorsqu'on utilise un cadriciel (ex.: Laravel, NextJS, etc.), des
              outils de routage sont généralement fournis par le cadriciel
            </li>
            <li>
              Sans cadriciel, il est possible d'utiliser des librairies qui
              facilitent le routage
            </li>
          </ul>
        </section>

        <section>
          <h2>Librairie PHP Router</h2>
          <img src="./images/phprouter.png" />
          <ul>
            <li>
              Disponible sur
              <a href="https://phprouter.com">phprouter.com</a> et
              <a href="https://github.com/phprouter/main">GitHub</a>
            </li>
            <li>Inconnue du grand public</li>
            <li>Implémentation simple et efficace d'un routeur</li>
            <li>
              Seules les méthodes HTTP les plus communes sont implémentées
            </li>
          </ul>
        </section>

        <section>
          <h2>Utilisation de PHP Router</h2>
          <pre><code class="php" data-trim data-line-numbers="1|3-6|8-12|14-15">
            // Syntaxe: method(route, script);

            // ***** Routes statiques *****
            get('/', '/web/index.php');
            post('/login', '/web/login.php');
            any('/newUser', '/web/newUser');
            
            // ***** Routes dynamiques *****
              //$id sera disponible dans le script getClient.php
            get('/api/clients/$id', '/api/getClient.php');
            delete('/api/produits/$id', '/api/produits/delProduit.php');
            post('/api/produits/$categorie/$id', '/api/produits/postProduit.php');

            // ***** Routes invalide *****
            any('/404', '/erreur.php');
          </code></pre>
        </section>

        <section>
          <h2>Traitement d'une requête</h2>
          <pre><code class="php" data-trim>
          //Utiliser les paramètres de la requête directement
          //Toujours s'assurer de la validité des données reçues  
          if(isset($id) && filter_var($id, FILTER_VALIDATE_INT)){
            $stmt = $pdo->prepare("SELECT * FROM `postits` WHERE `id`=:id");
            //...
            $postit = $stmt->fetch();
          } else {
            $postit = ["error"=>"Identifiant invalide"];
          }
          </code></pre>
        </section>

        <section>
          <h2>Utilisation des codes HTTP pour la réponse</h2>
          <ul>
            <li>
              Les codes HTTP permettent de préciser au client la nature de la
              réponse
            </li>
            <li>
              Consulter la
              <a href="https://developer.mozilla.org/fr/docs/Web/HTTP/Status"
                >liste des codes HTTP</a
              >
              et retourner la valeur la plus appropriée
            </li>
            <li>
              Le code par défaut sera 200 (OK), il n'est pas nécessaire de le
              préciser
            </li>
            <li>
              La fonction http_response_code permet de renvoyer le bon code,
              suivi d'un message informatif:
              <pre><code class="php" data-trim>
                http_response_code(400);
                echo "Requête invalide";
                exit;
              </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>Préparation de la réponse</h2>
          <ul>
            <li>
              Généralement, une réponse à une requête dirigée vers une API REST
              est de type JSON (objet, tableau d'objets, etc.)
            </li>
            <li>
              Toujours spécifier le type de réponse et l'encodage:
              <pre><code class="php" data-trim>
                header('Content-Type: application/json; charset=utf-8');
              </code></pre>
            </li>
            <li>
              La fonction PHP <code>json_encode</code> permet de transformer le
              contenu d'une variable en son équivalent JSON stocké dans une
              chaine de caractères
              <pre><code class="php" data-trim="">
                echo json_encode($postits);
              </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h2>Requêtes avec contenu (POST/PUT)</h2>
          <ul>
            <li>
              Une requête contient souvent des données dans le corps de la
              requête (pas dans l'URL)
              <pre><code class="javascript" data-trim data-line-numbers="|7-8">
                let data = {id: 10, titre:"Mon titre", contenu:"Mon contenu"};
                fetch("/api/postits/"+id, {
                  method: 'PUT', // Méthode HTTP
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  // Convertir l'objet de données en chaîne JSON
                  body:  JSON.stringify(data)
                })
                //...
              </code></pre>
            </li>
            <li class="fragment">
              Utiliser le flux <code class="highlight2">php://input</code> pour
              lire le contenu du corps de la requête (body):
              <pre><code class="php" data-trim>
                $body = json_decode(file_get_contents("php://input"));
              </code></pre>
            </li>
            <li></li>
          </ul>
        </section>

        <section>
          <h2>Authentification REST: Méthodes</h2>
          <ul>
            <li>
              Souvent, l'accès à une ressource ou une méthode via une API REST
              requiert des privilèges
            </li>
            <li>
              L'authentification se fait généralement sans intervention de
              l'usager
            </li>
            <li>
              Les données d'authentification doivent être incluses dans la
              requête
            </li>
          </ul>
        </section>

        <section>
          <h2>Authentification REST: Méthodes</h2>
          <ul>
            <li>
              Données d'authentification incluses dans le corps de la requête
            </li>
            <li>Basic</li>
            <li>Bearer Token (OAuth 2.0, JWT, OpenID)</li>
            <li>Clés d'API</li>
            <li>La session (si disponible)</li>
          </ul>
        </section>

        <section>
          <h2>Authentification: Corps de la requête</h2>
          <pre><code class="javascript" data-trim>
            let data = {
              id: 10, titre:"Mon titre", contenu:"Mon contenu",
              username: "toto",
              password: "bonjour"
            };
            fetch("/api/postits/"+id, {
              method: 'PUT', // Méthode HTTP
              headers: {
                  'Content-Type': 'application/json'
              },
              // Convertir l'objet de données en chaîne JSON
              body:  JSON.stringify(data)
            })
            //...
          </code></pre>
          <p class="fragment highlight">Méthode peu sécurisée!</p>
        </section>

        <section>
          <h2>Authentification: BASIC</h2>
          <ul>
            <li>Une des méthodes les plus simples</li>
            <li>
              Utilise un nom d'utilisateur et un mot de passe encodés en Base64
              dans l'en-tête de la requête HTTP
            </li>
            <li>
              Peu sécurisée: les identifiants peuvent être facilement décodés si
              la connexion n'est pas chiffrée
            </li>
          </ul>
        </section>

        <section>
          <h2>Authentification: BASIC</h2>
          <ul>
            <li>
              Codes d’authentification envoyés dans l'entête
              <code>`Authorization`</code>, encodées en Base64 (fonction
              <a href="https://developer.mozilla.org/fr/docs/Web/API/btoa"
                ><code>btoa</code></a
              >)
            </li>
            <li>Format: <code>Basic username:password</code></li>
          </ul>
          <pre><code class="javascript" data-trim>
            // Vos identifiants
            const username = 'votre_nom_d_utilisateur';
            const password = 'votre_mot_de_passe';
            // Encodage en Base64
            const base64 = btoa(username + ":" + password);

            // Exécution de la requête avec l'en-tête d'authentification
            fetch('https://votre-api.com/chemin', {
              method: 'GET', // ou 'POST', 'PUT', 'DELETE', etc. selon le besoin
              headers: {
                // Ajout de l'en-tête d'authentification Basic
                'Authorization': 'Basic ' + base64
              }
            }) //...
          </code></pre>
        </section>

        <section>
          <h2>Authentification: Bearer Token</h2>
          <ul>
            <li>
              Méthode qui implique l'utilisation de tokens d'accès envoyés dans
              l'en-tête de la requête.
            </li>
            <li>
              Le client doit d'abord s'authentifier auprès du serveur
              d'autorisation pour recevoir un token
            </li>
            <li>Le token utilisera ensuite pour accéder à l'API</li>
            <li class="highlight2">
              Une méthode sécurisée et largement adoptée, en particulier pour
              les applications web et mobiles.
            </li>
          </ul>
        </section>

        <section>
          <h2>Authentification: Bearer Token</h2>
          <p>Plusieurs implémentations:</p>
          <ul>
            <li>
              <strong>JWT (JSON Web Token):</strong> des tokens encodés qui
              peuvent stocker un ensemble de claims (par exemple, identité de
              l'utilisateur, permissions). Ils sont vérifiés et validés par
              l'API à chaque requête.
            </li>
            <li>
              <strong>OAuth 2.0:</strong>Cadre standardisé qui permet à des
              applications tierces d'accéder à des ressources au nom de
              l'utilisateur, sans divulguer ses identifiants. OAuth 2.0 définit
              plusieurs flux (grant types) pour obtenir des tokens.
            </li>
            <li>
              <strong>OpenId Connect:</strong> Extension de OAuth 2.0 et JWT
            </li>
            <li></li>
          </ul>
        </section>

        <section>
          <h2>Authentification: Clés d'API</h2>
          <ul>
            <li>Permet l'identification et non l'authentification</li>
            <li>Clé d'accès à l'API fournie par le fournisseur</li>
          </ul>
          <img
            src="./images/apikey-openai.png"
            style="border: 1px solid #000"
          />
        </section>

        <section data-menu-title="Fin">
          <h1>&lt;/Chapitre 06&gt;</h1>
        </section>
      </div>
    </div>

    <script src="../revealjs/reveal.js"></script>
    <script src="../revealjs/plugin/notes/notes.js"></script>
    <script src="../revealjs/plugin/markdown/markdown.js"></script>
    <script src="../revealjs/plugin/highlight/highlight.js"></script>
    <script src="../revealjs/plugin/menu/menu.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu],

        menu: {
          side: "left",
          width: "wide", //'normal', 'wide', 'third', 'half', 'full', or css valid length
          numbers: false,
          titleSelector: "h1, h2, h3, h4, h5, h6",
          useTextContentForMissingTitles: true,
          hideMissingTitles: false,
          markers: true,
          custom: false,
          themes: false,
          themesPath: "dist/theme/",
          transitions: false,
          openButton: true,
          openSlideNumber: false,
          keyboard: true,
          sticky: false,
          autoOpen: true,
          delayInit: false,
          openOnInit: false,
          loadIcons: true,
        },
      });
    </script>
    <script src="../timeline/js/timeline.min.js"></script>
    <script>
      timeline(document.querySelectorAll(".timeline"));

      Reveal.on("slidechanged", (event) => {
        // event.previousSlide, event.currentSlide, event.indexh, event.indexv
        let panel = document.getElementById("slide_nb");
        if (event.currentSlide.classList.contains("slidenb")) {
          panel.textContent = event.currentSlide.dataset.slidenb;
          panel.style.display = "block";
        } else {
          panel.style.display = "none";
        }
      });
    </script>
    <script src="../tree.jquery.js"></script>
    <script src="./ch4.js"></script>
  </body>
</html>
